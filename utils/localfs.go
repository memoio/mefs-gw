package utils

import (
	"errors"
	"io"
	"io/ioutil"
	"os"
	"path"
	"strings"
	"sync"

	bsrv "github.com/ipfs/go-blockservice"
	ds "github.com/ipfs/go-datastore"
	dssync "github.com/ipfs/go-datastore/sync"
	blockstore "github.com/ipfs/go-ipfs-blockstore"
	chunker "github.com/ipfs/go-ipfs-chunker"
	offline "github.com/ipfs/go-ipfs-exchange-offline"
	ipld "github.com/ipfs/go-ipld-format"
	dag "github.com/ipfs/go-merkledag"
	"github.com/ipfs/go-unixfs/importer"

	"github.com/minio/minio-go/v7/pkg/s3utils"
	minio "github.com/minio/minio/cmd"
)

// StorageErr represents error generated by xlStorage call.
type StorageErr string

func (h StorageErr) Error() string {
	return string(h)
}

// errIsNotRegular - not of regular file type.
var errIsNotRegular = StorageErr("not of regular file type")

// Mock returns a new thread-safe, mock DAGService.
func MockDagService() ipld.DAGService {
	return dag.NewDAGService(Bserv())
}

// Bserv returns a new, thread-safe, mock BlockService.
func Bserv() bsrv.BlockService {
	bstore := blockstore.NewBlockstore(dssync.MutexWrap(ds.NewNullDatastore()))
	return bsrv.New(bstore, offline.Exchange(bstore))
}

type Bucket struct {
	sync.Mutex
	dir     string
	tempMap map[string]bool
}

type LocalFS struct {
	sync.Mutex
	rootDir string
	tempMap map[string]*Bucket
}

func OpenLocalFS(rootDir string) (*LocalFS, error) {
	stat, err := os.Stat(rootDir)
	if err == nil && !stat.IsDir() {
		return nil, errors.New("not dir")
	}

	if os.IsNotExist(err) {
		err = os.Mkdir(rootDir, 0777)
		if err != nil {
			return nil, err
		}
	}

	if err != nil {
		return nil, err
	}

	files, err := ioutil.ReadDir(rootDir)
	if err != nil {
		return nil, err
	}

	sfs := &LocalFS{
		rootDir: rootDir,
		tempMap: make(map[string]*Bucket),
	}

	for _, v := range files {
		name := v.Name()
		if v.IsDir() && strings.HasPrefix(name, "bucket.") {
			bname := strings.TrimPrefix(name, "bucket.")
			sfs.tempMap[bname] = &Bucket{
				dir:     path.Join(sfs.rootDir, name),
				tempMap: make(map[string]bool),
			}
		}
	}

	return sfs, nil
}

func (fs *LocalFS) GetBucketPath(bucketName string) string {
	return path.Join(fs.rootDir, "bucket."+bucketName)
}

func (fs *LocalFS) MakeBucket(bucketName string) error {
	fs.Lock()
	defer fs.Unlock()

	bucket, ok := fs.tempMap[bucketName]
	if ok && bucket != nil {
		return minio.BucketExists{Bucket: bucketName}
	}

	err := s3utils.CheckValidBucketNameStrict(bucketName)
	if err != nil {
		return minio.ErrorRespToObjectError(err, bucketName)
	}

	dirPath := fs.GetBucketPath(bucketName)
	if err = os.Mkdir((dirPath), 0777); err != nil {
		return minio.ErrorRespToObjectError(err, bucketName)
	}

	bucket = &Bucket{
		dir:     dirPath,
		tempMap: make(map[string]bool),
	}

	fs.tempMap[bucketName] = bucket

	return nil
}

func (fs *LocalFS) GetBucketInfo(bucketName string) (bi minio.BucketInfo, err error) {
	err = s3utils.CheckValidBucketNameStrict(bucketName)
	if err != nil {
		return bi, minio.ErrorRespToObjectError(err, bucketName)
	}

	dirPath := fs.GetBucketPath(bucketName)
	stat, err := os.Stat(dirPath)
	if err != nil {
		return bi, minio.ErrorRespToObjectError(err, bucketName)
	}
	bi.Name = stat.Name()
	bi.Created = stat.ModTime()

	return bi, nil
}

func (fs *LocalFS) CheckBucket(bucketName string) error {
	err := s3utils.CheckValidBucketNameStrict(bucketName)
	if err != nil {
		return minio.ErrorRespToObjectError(err, bucketName)
	}

	dirPath := fs.GetBucketPath(bucketName)
	_, err = os.Stat(dirPath)
	if err != nil {
		return minio.ErrorRespToObjectError(err, bucketName)
	}
	return nil
}

func (fs *LocalFS) PutObject(bucketName, objectName string, r io.Reader) (io.Reader, io.Closer, error) {
	bucket, ok := fs.tempMap[bucketName]
	if !ok || bucket == nil {
		return nil, nil, minio.BucketNotFound{Bucket: bucketName}
	}

	ok = bucket.tempMap[objectName]
	if ok {
		return nil, nil, minio.ObjectAlreadyExists{Bucket: bucketName, Object: objectName}
	}

	bucket.Lock()
	bucket.tempMap[objectName] = true
	bucket.Unlock()

	p := path.Join(fs.GetBucketPath(bucketName), objectName)

	_, err := os.Stat(p)
	if !os.IsNotExist(err) {
		return nil, nil, minio.ObjectAlreadyExists{Bucket: bucketName, Object: objectName}
	}

	temp := p + ".tmp"
	f, err := os.Create(temp)
	if err != nil {
		return nil, nil, minio.ErrorRespToObjectError(err, bucketName, objectName)
	}

	wrapReader := io.TeeReader(r, f)

	return wrapReader, f, err
}

func (fs *LocalFS) FinishPut(bucketName, objectName string) error {
	bucket, ok := fs.tempMap[bucketName]
	if !ok || bucket == nil {
		return minio.BucketNotFound{Bucket: bucketName}
	}

	p := path.Join(fs.GetBucketPath(bucketName), objectName)
	_, err := os.Stat(p)
	if !os.IsNotExist(err) {
		return minio.ObjectAlreadyExists{Bucket: bucketName, Object: objectName}
	}

	temp := p + ".tmp"

	err = os.Rename(temp, p)

	bucket.Lock()
	delete(bucket.tempMap, objectName)
	bucket.Unlock()

	return minio.ErrorRespToObjectError(err, bucketName, objectName)
}

func (fs *LocalFS) GetObject(bucketName, objectName string, offset int64) (io.ReadCloser, int64, error) {
	p := path.Join(fs.GetBucketPath(bucketName), objectName)
	fr, err := os.Open(p)
	if err != nil {
		return nil, 0, minio.ErrorRespToObjectError(err, bucketName, objectName)
	}
	// Stat to get the size of the file at path.
	st, err := fr.Stat()
	if err != nil {
		fr.Close()
		return nil, 0, minio.ErrorRespToObjectError(err, bucketName, objectName)
	}

	// Verify if its not a regular file, since subsequent Seek is undefined.
	if !st.Mode().IsRegular() {
		fr.Close()
		return nil, 0, errIsNotRegular
	}

	// Seek to the requested offset.
	if offset > 0 {
		_, err = fr.Seek(offset, io.SeekStart)
		if err != nil {
			fr.Close()
			return nil, 0, err
		}
	}

	return fr, st.Size(), nil
}

func (fs *LocalFS) GetObjectInfo(bucketName, objectName string) (minio.ObjectInfo, error) {
	p := path.Join(fs.GetBucketPath(bucketName), objectName)
	stat, err := os.Stat(p)
	if os.IsNotExist(err) {
		return minio.ObjectInfo{}, minio.ObjectNotFound{Bucket: bucketName, Object: objectName}
	}
	if err != nil {
		return minio.ObjectInfo{}, minio.ErrorRespToObjectError(err, bucketName, objectName)
	}

	return minio.ObjectInfo{
		Bucket:  bucketName,
		Name:    objectName,
		Size:    stat.Size(),
		ModTime: stat.ModTime(),
	}, nil
}

func (fs *LocalFS) ListObjects(bucketName string) (loi minio.ListObjectsInfo, err error) {
	err = s3utils.CheckValidBucketNameStrict(bucketName)
	if err != nil {
		return loi, minio.ErrorRespToObjectError(err, bucketName)
	}
	dirPath := fs.GetBucketPath(bucketName)

	files, err := ioutil.ReadDir(dirPath)
	if err != nil {
		return loi, minio.ErrorRespToObjectError(err, bucketName)
	}

	for _, file := range files {
		if !file.IsDir() {
			name := file.Name()
			if !strings.HasSuffix(name, ".tmp") {
				loi.Objects = append(
					loi.Objects,
					minio.ObjectInfo{
						Bucket:  bucketName,
						Name:    name,
						ModTime: file.ModTime(),
						Size:    file.Size(),
						IsDir:   false,
					},
				)
			}
		}
	}

	return loi, nil
}

func (fs *LocalFS) ListObjectsV2(bucketName string) (loi minio.ListObjectsV2Info, err error) {
	err = s3utils.CheckValidBucketNameStrict(bucketName)
	if err != nil {
		return loi, minio.ErrorRespToObjectError(err, bucketName)
	}
	dirPath := fs.GetBucketPath(bucketName)

	files, err := ioutil.ReadDir(dirPath)
	if err != nil {
		return loi, minio.ErrorRespToObjectError(err, bucketName)
	}

	for _, file := range files {
		if !file.IsDir() {
			name := file.Name()
			if !strings.HasSuffix(name, ".tmp") {
				loi.Objects = append(
					loi.Objects,
					minio.ObjectInfo{
						Bucket:  bucketName,
						Name:    name,
						ModTime: file.ModTime(),
						Size:    file.Size(),
						IsDir:   false,
					},
				)
			}
		}
	}

	return loi, nil
}

func (fs *LocalFS) CidOf(bucketName, objectName string) (string, error) {
	p := path.Join(fs.GetBucketPath(bucketName), objectName)
	f, err := os.Open(p)
	if err != nil {
		return "", minio.ErrorRespToObjectError(err, bucketName, objectName)
	}

	ds := MockDagService()
	nd, err := importer.BuildDagFromReader(ds, chunker.NewSizeSplitter(f, chunker.DefaultBlockSize))
	if err != nil {
		return "", nil
	}
	return nd.Cid().String(), nil
}

func (fs *LocalFS) DeleteObject(bucketName, objectName string) error {
	p := path.Join(fs.GetBucketPath(bucketName), objectName)
	err := os.Remove(p)
	return err
}
